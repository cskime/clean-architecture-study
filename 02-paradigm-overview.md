# Paradigm Overview

> Clean Architecture 2부 3~6장

패러다임(paradigm)은 정해준 구조, 규칙에 맞게 실행되며 임의로 벗어날 수 없게 만드는 것. 즉, 각 패러다임은 프로그래머에게서 권한을 박탈한다. 프로그래머가 어떤 것을 하면 안되는지를 말해준다.

- 구조적 프로그래밍 : `go to`문을 사용한 제어 흐름의 직접적인 전환을 금지
- 객체 지향 프로그래밍 : 다형성을 interface(protocol)로 구현하여 함수 포인터 사용을 금지
- 함수형 프로그래밍 : 동시성 문제를 유발하는 가변 변수의 할당문 사용을 금지

`go to`문, 함수 포인터, 할당문 등 더 이상 프로그래머에게서 가져갈 요소가 없기 떄문에, 이 패러다임들이 만들어진 후 10년이 넘도록 새로운 패러다임은 나타나지 않았고 앞으로도 그럴 것이다.

## 구조적 프로그래밍

> 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.

- 데이크스트라(Edsger Wybee Dijkstra)가 무분별한 점프(`go to`문)가 프로그램 구조에 해롭다는 것을 발견하고, `if/then/else`와 `do/while/until`같은 익숙한 구조로 대체
    - `go to`문을 사용해서 임의의 위치로 무분별하게 이동하는 것은 코드가 올바르다는 사실을 증명할 때 사용하는 '분할 정복 접근법'을 사용할 수 없게 만든다.
    - `go to`문을 무분별하게 사용하면 예상치 못한 동작을 하므로 올바른 코드임을 증명할 수 없다.
    - `go to`문은 **분기(`if-else`)와 반복(`do/while`)** 에서만 사용하는 것이 좋음
- 모든 프로그램은 **순차**, **분기**, **반복** 세 가지 구조만으로 표현할 수 있다.
- 현대의 프로그램이 언어들은 `go to` 문법을 없애거나 사용 범위를 현재 함수 안으로 제한하는 등 기능을 축소하고 있음

### 기능적 분해

- `go to`를 사용하지 않음으로써 구조적 프로그래밍이 시작되었고, 이로 인해 증명 가능한 작은 단위로 모듈을 분리하고 이 모듈을 기능적으로 분해할 수 있게 됨
- **구조적 분석**이나 **구조적 설계**와 같은 기법이 사용되기 시작
- 대규모 시스템을 **모듈**과 **컴포넌트**로 나눌 수 있다.

### 테스트

- 프로그램의 세세한 기능을 엄밀하게 증명하기보다, '과학'에서의 증명 방법을 적용
- 과학은 서술된 내용이 사실임을 증명하는게 아닌 서술이 틀렸음을 증명함으로써 참임을 증명한다.
    - 즉, **어떤 방법으로도 거짓임을 증명할 수 없다면 목표에 부합할 만큼은 참으로 본다.**
    - **올바르지 않음을 증명하는데 실패함으로써 올바름을 보여준다.**
- **테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.**
- 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해 주는 것이 전부다.
- `go to`문을 남발하면 예측 불가능하기 때문에 프로그램 증명이 불가능해지고, 이러한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르다고 할 수 없다.

**아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들어야 한다.**

## 객체 지향 프로그래밍

> 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

- 함수 호출 스택 프레임을 힙으로 옮기면 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견
    - 이것이 클래스의 '**생성자**'가 됨
    - 힙에서 오랫동안 유지되는 데이터들은 '**클래스 멤버**'가 됨
- 함수 포인터를 특정한 규칙에 의해 사용하도록 만들며 '**다형성**' 등장

## 함수형 프로그래밍

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

- 수학의 '람다 계산법'의 영향을 받아 만들어진 패러다임
- '**불변성**' 특징을 가짐. 프로그래밍에서는 변수의 값을 변경하는 '**할당문이 없다**'는 의미
- 할당문이 없거나, 굉장히 까다로운 조건 아래에서만 변수 할당을 허용함