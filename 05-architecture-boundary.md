# Architecture - Boundary

> Clean Architecture 5부 17~18장

- 앞에서 다룬 내용은 결국 **컴포넌트 간 경계(boundary)선 긋기**의 기술
- 업무 규칙을 중심으로, 가능한 결정을 최대한 미뤄야 하는 컴포넌트들과 경계 선을 긋는다.
- 경계 선을 그으면,
    - 업무 규칙과 UI, 업무 규칙과 DB 사이에 경계선을 긋는다.
    - UI와 DB 사이에도 경계가 생긴다.
    - 이들 사이에 '인터페이스'를 사용해서
        - 저수준 세부사항(UI, DB)이 고수준 추상화 요소(업무 규칙) 방향으로 의존하게 만들고 (SAP, DIP)
        - 고수준 추상화 요소는 저수준 세부사항의 결정을 최대한 미룬 채로 인터페이스에 정의된 함수만 사용해서 데이터를 요청하고 반환한다.
    - 인터페이스를 사용하면 세부사항들은 단순히 stub으로 사용해서 업무 규칙만 별도로 테스트하고 개발할 수 있다.
- 즉, 좋은 시스템 아키텍처는 **경계선**을 잘 그어서 **세부사항들을 가능 한 마지막에 결정**할 수 있게 해 준다.

## 세부사항 결정을 미룸으로써 얻는 것

DB를 사용하는 결정을 최대로 미루고 단순히 파일 시스템에 read/write하게 개발하면서 얻는 이점

- 스키마, 쿼리, 데이터베이스 서버, 패스워드, 접속 시간 등에서 발생할 수 있는 문제가 없다.
- 기타 데이터베이스를 작동시킬 때 발생할 수 있는 문제가 없다.
- 테스트를 느리게 만드는 DB가 없으므로 더 빠르게 테스트할 수 있다.

## 경계선 긋기 기술

- **관련이 있는 것과 없는 것 사이에 선을 긋는다.**
- SRP 또는 CCP 원칙과 관련이 있다.
    - 서로 다른 속도와 방향으로 변경되는 것들 끼리 분리한다.
    - SRP와 CCP는 어디에 선을 그어야 할지 알려준다.
- 경계선을 긋는 데에는 DIP와 SAP 원칙이 적용된다.
    - DIP : 인터페이스를 사용하여 제어 흐름과 의존성 방향을 역전시킨다.
        - 제어흐름 : 업무 규칙 -> DB
        - 의존성 : DB -> 업무 규칙
    - SAP : 불안정한 저수준 세부사항이 안정된 고수준의 추상화된 컴포넌트에 의존한다.
        - 불안정한 저수준 세부사항 : UI, DB
        - 안정된 고수준의 추상화된 컴포넌트 : 업무 규칙 사이에 존재하는 인터페이스
        - UI, DB 등 저수준 세부사항이 업무 규칙이 가진 추상화된 인터페이스에 의존하도록 만든다.
- 경계선은 '**변경의 축(axis of change)**'에 긋는다.
- 업무 규칙을 중심으로 UI와 DB 사이에 선을 긋는다.
    - 경계선 긋기는 업무 규칙을 관련이 없는 UI와 DB에서 발생하는 변경으로부터 독립적으로 분리시킨다.

### 업무 규칙과 DB

- 업무 규칙은 DB와 직접적인 관련이 없다. 
- 스키마 등을 알면 안되고 인터페이스를 통해 단순히 데이터에 접근하는 함수만 알아야 한다.
- DB가 업무 규칙으로부터 인터페이스 뒤로 숨는다.

<p align="center"><img src="img/boundary.png" width="500"></p>

- `DatabaseAccess`는 들어오는 화살표 없이 나가는 화살표만 있다.
- 즉, `DatabaseAccess`에 의존하는 클래스가 없다.
    - 불안정성 `I = Out / (In + Out) = 1`
    - 즉, 최고로 불안정한 상태에 있다.

<p align="center"><img src="img/boundary-db.png" width="200"></p>

- 크게 보면, DB가 업무 규칙에 의존하는 형태
- DB는 업무 규칙이 반드시 필요하지만, 업무 규칙은 실제 DB가 정해지지 않아도 된다.
- 즉, **어떤 DB도 사용할 수 있는 상태**가 된다.
- DB 결정을 최대한 늦추더라도 업무 규칙을 독립적으로 개발하고 테스트할 수 있다.

### 업무 규칙과 UI (입출력)

- 업무 규칙은 UI와 직접적인 관련이 없다.
    - UI 입력 : 사용자 이벤트
    - UI 출력 : 데이터를 화면에 보여주는 것
    - **입력과 출력은 중요하지 않다.**
- 업무 규칙과 UI 사이에 경계가 그어지고, **관련성이 낮은 컴포넌트에서 관련성이 높은 컴포넌트 방향으로** 의존성이 형성된다.
    <p align="center"><img src="img/boundary-ui.png" width="200"></p>
- 즉, 업무 규칙이 **어떤 UI도 사용할 수 있는 상태**가 된다.

## 플러그인 아키텍처

<p align="center"><img src="img/boundary-plugin.png" width="400"></p>

- 업무규칙이 DB 및 UI와 분리되어 경계가 그어진다. 
    - 핵심 업무규칙이 독립적으로 분리되어 있다.
- 업무 규칙은 어떤 DB나 UI라도 사용할 수 있고, 구체적으로 어떤 것을 사용할지 결정을 최대한 뒤로 늦출 수 있다.
- 즉, 업무 규칙에 DB와 UI를 '**플러그인**'으로 사용할 수 있게 된다.
    - 다른 DB와 UI로 쉽게 교체할 수 있다.
    - 쉽게 수정할 수 있다. == **Soft**ware
- 플러그인 형태를 가짐으로써, DB와 UI의 변경이 업무 규칙으로 전파되는 것을 막는다.
    - 즉, 어느 한 부분이 변경되더라도 관련 없는 다른 부분이 수정되는 것을 막는다.
