# Architecture

> Clean Architecture 5부 15~16장

## 좋은 아키텍처의 조건

- 아키텍처는 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만든다.
- 그러기 위해서는, **가능한 많은 선택지를 가능한 오래 남겨두는 전략을 따라야 한다.**
- **정책과 세부사항을 독립되게 분리시킨다.**
    - 정책 : 업무 규칙, 절차. Core Data
    - 세부사항 : 구체적인 방법, 선택사항들
    - "무엇을 어떻게 할 것인지"에서 "무엇을(정책)"이 "어떻게(세부사항)"와 독립적이어야 한다.
- **세부사항에 대한 결정을 가능한 한 오래 미룰 수 있는 방향으로 정책을 설계해야 한다.**
- 앱을 개발한다면,
    - 데이터를 '어떻게 가져와서', '어떻게 화면에 보여줄지'를 요구사항 / business logic을 구현하는 코드와 분리한다.
    - Network를 통해 가져올지, Storage에서 가져올지 상관 없이 business logic을 구현해야 한다.
    - Business logic을 실행한 결과를 어떤 모양의 UI를 가진 View에 전달할 지 알지 못한 채, 미리 정해둔 인터페이스에 의해 View 컴포넌트에 전달한다.
- 즉, **데이터를 어디서 가져와서 어떻게 보여줄지는 모르지만, 고수준 인터페이스를 사용해서 처리하고(busniess logic) 보여준다.**

### 개발

- 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침 해야 한다.
- 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘 잘 설계된 컴포넌트 단위로 분리해야 한다.

### 배포

- 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.

### 운영

- 아키텍처는 시스템을 운영하는데 필요한 요구를 알려준다.
- 유스케이스(Use Case), 기능, 시스템 필수 행위를 일급 엔티티(first-class entity)로 취급하여 개발자에게 주요 목표로 인식시킨다.
- 개발자는 시스템을 이해하기 쉬워지고, 개발과 유지보수에 도움을 준다.

### 유지보수

- 탐사(spelunking) : 새로운 기능을 추가하거나 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는게 최선인지 어떤 전략을 쓰는게 최적일지 결정할 때 드는 비용
- 탐사에 의해 의도치 않은 결함이 발생하고 이로 인한 위험부담이 증가한다.
- 이 비용을 줄이기 위해, **시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로를 격리한다.**
- 즉, 안정된 인터페이스로 컴포넌트를 분리하여 변경이 발생했을 때 전파되는 범위를 최소화하여 의도치 않은 결함과 버그로부터 지켜낸다.

### 선택 사항 열어두기

- 소프트웨어는 '**구조적 가치**'에 의해 부드러워(soft)진다.
- 소프트웨어는 부드러워야 기계의 행위를 빠르고 쉽게 변경할 수 있다.
- 소프트웨어를 부드럽게 유지하는 방법은 **선택사항을 가능한 한 많이, 그리고 오래 열어두는 것이다.**
    - 선택사항 : 덜 중요한 세부사항 (e.g. 입출력 장치, 데이터페이스, 서버, 프레임워크, 통신 프로토콜 등)
    - 정책 : 업무 규칙과 절차
- 아키텍트는 정책을 가장 핵심 요소로 식별하고, 세부사항과 정책을 분리시켜야 한다.
- **정책이 세부사항에 의존하지 않음**으로써, 세부사항을 결정하는 일을 오래 미룰 수 있고 더 많은 정보를 가지고 최선의 선택을 할 수 있게 된다.
    - 여러 기술들을 후보에 두고 적용 가능성과 성능을 충분히 검토해 볼 수 있다.

### 세부사항을 열어두는 예시

- 개발 초기에는 정책이 **구체적인 데이터베이스의 종류를 신경쓰지 않도록 개발한다.**
    - 관계형인지, 분산형인지, 계층형인지
    - 평범함 플랫 파일인지
- 개발 초기에는 정책이 **구체적인 전달되는 방식에 신경쓰지 않도록 개발한다.**
    - 웹을 사용할 것인지
    - 웹 중에서도 어떤 기술을 사용할 것인지 (HTML, AJAX, JSF 등)
- 개발 초기에는 REST를 적용하지 않고, **정책이 외부 세계로의 인터페이스에 대해 독립적이도록 개발한다.**
- 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다. **고수준 정책은 의존성 해석 방식을 신경써서는 안된다.**

### 장치 독립성

- **소프트웨어가 어떤 장치에서 사용되는지에 관계 없이 동작할 수 있게 개발**해야 한다.
- 소프트웨어가 천공 카드 판독기에 의존하여 세부사항을 모두 아는 상태로 개발되었다면, 나중에 자기 테이프로 바뀌었을 때 소프트웨어 전체를 다시 개발해야 한다.
- 정책(데이터)과 세부사항(프린트 방법)을 독립적으로 분리

## 독립성